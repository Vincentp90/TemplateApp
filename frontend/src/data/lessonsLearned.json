[
  { "id": 1, "title": "Avoid unnecessary useState and useEffect", "info": "If a state is never changing then there is no point in using useState. UseEffect is not needed when we derive the data from data we already have. Example of bad code: [[code]]const data = [\n  { id: 1, title: \"Card A\", info: \"Useful info A\" },\n  { id: 2, title: \"Card B\", info: \"Useful info B\" },\n  { id: 3, title: \"Card C\", info: \"Useful info C\" }\n];\n\nfunction shuffle(array) {\n  return [...array].sort(() => Math.random() - 0.5);\n}\n\nexport default function RandomCards() {\n  const [cards, setCards] = useState([]);\n\n  useEffect(() => {\n    setCards(shuffle(data));\n  }, []);\n\n  return (\n    <>{cards.map((card) => (\n        <div key={card.id}>\n          <h2>{card.title}</h2>\n          <p>{card.info}</p>\n        </div>\n      ))}</>\n  );\n}[[endcode]] We can simply call shuffle immediatly instead of using state (and useEffect): [[code]]export default function RandomCards() {\n  const cards = shuffle(data);\n\n  return (\n    <>{cards.map((card) => (\n        <div key={card.id}>\n          <h2>{card.title}</h2>\n          <p>{card.info}</p>\n        </div>\n      ))}</>\n  );\n}[[endcode]]" },
  { "id": 2, "title": "Use a query library instead of fetching from useEffect", "info": "Using a query library like Tanstack Query lets you avoid making badly designed useEffect that could trigger unnecessarily, increasing backend load needlessly. Cloudflare overloaded their own service because of a useEffect loop. Loops are still possible when using a query library but it's harder to shoot yourself in the foot. UseEffect should only be used for: global event listeners, direct interaction with a DOM element, doing something when a component mounts, external things (like js libraries) Source: https://www.youtube.com/watch?v=WPt05AGFB-Q" },
  { "id": 3, "title": "Dealing with CORS", "info": "For development we deal with CORS by just allowing the port of our frontend on localhost. In the production setup we dockerize both backend and frontend, then we use a reverse proxy so requests to the backend are coming from the same domain as the frontend. This way we can run the backend without allowing any origins. A BFF (backend service which also serves the react frontend on same domain) could be another solution but I still need to learn the pros and cons of this." },
  { "id": 4, "title": "Dockerfile build stages", "info": "Docker build stages let you exclude build tools from the image. This way you end up with a smaller image. A typical dockerfile will have a first stage where it installs buildtools and then build. Then a second (and final) stage where it copies the build artifacts from the first to the second stage. Only the final stage is included in the final image." },
  { "id": 5, "title": "Entity Framework with Postgres", "info": "This is my first time using entity framework with postgres. At first it was not working because C# pascal case names were not matching Postgres' snake case. Using UseSnakeCaseNamingConvention seems to be the best solution. [[code]]builder.Services.AddDbContext<WishlistDbContext>(options => \n options.UseNpgsql(builder.Configuration.GetConnectionString(\"DefaultConnection\")).UseSnakeCaseNamingConvention());[[endcode]]" },
  { "id": 6, "title": "Sidebar scrolls with content", "info": "The sidebar scrolls with content. Alas, I'm not good with CSS, it's of very little interest to me and ChatGPT couldn't help me." }
]
