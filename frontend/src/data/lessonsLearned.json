[
  { "id": 1, "title": "Avoid unnecessary useState", "info": "If a state is never changing then there is no point in using useState. Example of bad code: [[code]]const data = [\n  { id: 1, title: \"Card A\", info: \"Useful info A\" },\n  { id: 2, title: \"Card B\", info: \"Useful info B\" },\n  { id: 3, title: \"Card C\", info: \"Useful info C\" }\n];\n\nfunction shuffle(array) {\n  return [...array].sort(() => Math.random() - 0.5);\n}\n\nexport default function RandomCards() {\n  const [cards, setCards] = useState([]);\n\n  useEffect(() => {\n    setCards(shuffle(data));\n  }, []);\n\n  return (\n    <>{cards.map((card) => (\n        <div key={card.id}>\n          <h2>{card.title}</h2>\n          <p>{card.info}</p>\n        </div>\n      ))}</>\n  );\n}[[endcode]] We can simply call shuffle immediatly instead of using state (and useEffect): [[code]]export default function RandomCards() {\n  const cards = shuffle(data);\n\n  return (\n    <>{cards.map((card) => (\n        <div key={card.id}>\n          <h2>{card.title}</h2>\n          <p>{card.info}</p>\n        </div>\n      ))}</>\n  );\n}[[endcode]]" },
  { "id": 2, "title": "Avoid unnecessary useEffect", "info": "Improper useEffect usage can cause unnecessary rerenders. Example of bad code: <pre><code>TODO</code></pre>" },
  { "id": 3, "title": "Use a query library", "info": "Using a query library like Tanstack Query lets you avoid making badly designed useEffect that could trigger unnecessarily, increasing backend load needlessly. Cloudflare example TODO." },
  { "id": 4, "title": "Card D", "info": "TODO Useful info D" }
]
