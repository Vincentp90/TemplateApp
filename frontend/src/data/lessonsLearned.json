[
  { "id": 1, "theme": "react", "title": "Avoid unnecessary useState and useEffect", "info": "If a state is never changing then there is no point in using useState. UseEffect is not needed when we derive the data from data we already have. Example of bad code: [[code]]const data = [\n  { id: 1, title: \"Card A\", info: \"Useful info A\" },\n  { id: 2, title: \"Card B\", info: \"Useful info B\" },\n  { id: 3, title: \"Card C\", info: \"Useful info C\" }\n];\n\nfunction shuffle(array) {\n  return [...array].sort(() => Math.random() - 0.5);\n}\n\nexport default function RandomCards() {\n  const [cards, setCards] = useState([]);\n\n  useEffect(() => {\n    setCards(shuffle(data));\n  }, []);\n\n  return (\n    <>{cards.map((card) => (\n        <div key={card.id}>\n          <h2>{card.title}</h2>\n          <p>{card.info}</p>\n        </div>\n      ))}</>\n  );\n}[[endcode]] We can simply call shuffle immediatly instead of using state (and useEffect): [[code]]export default function RandomCards() {\n  const cards = shuffle(data);\n\n  return (\n    <>{cards.map((card) => (\n        <div key={card.id}>\n          <h2>{card.title}</h2>\n          <p>{card.info}</p>\n        </div>\n      ))}</>\n  );\n}[[endcode]]" },
  { "id": 2, "theme": "react", "title": "Use a query library instead of fetching from useEffect", "info": "Using a query library like Tanstack Query lets you avoid making badly designed useEffect that could trigger unnecessarily, increasing backend load needlessly. Cloudflare overloaded their own service because of a useEffect loop. Loops are still possible when using a query library but it's harder to shoot yourself in the foot. UseEffect should only be used for: global event listeners, direct interaction with a DOM element, doing something when a component mounts, external things (like js libraries) Source: https://www.youtube.com/watch?v=WPt05AGFB-Q" },
  { "id": 3, "theme": "nginx", "title": "Dealing with CORS", "info": "For development we deal with CORS by just allowing the port of our frontend on localhost. In the production setup we dockerize both backend and frontend, then we use a reverse proxy so requests to the backend are coming from the same domain as the frontend. This way we can run the backend without allowing any origins. A BFF (backend service which also serves the react frontend on same domain) could be another solution but I still need to learn the pros and cons of this." },
  { "id": 4, "theme": "docker", "title": "Dockerfile build stages", "info": "Docker build stages let you exclude build tools from the image. This way you end up with a smaller image. A typical dockerfile will have a first stage where it installs buildtools and then build. Then a second (and final) stage where it copies the build artifacts from the first to the second stage. Only the final stage is included in the final image." },
  { "id": 5, "theme": "dotnet", "title": "Entity Framework with Postgres", "info": "This is my first time using Entity Framework with Postgres. At first it was not working because C# pascal case names were not matching Postgres' snake case. Using UseSnakeCaseNamingConvention seems to be the best solution. [[code]]builder.Services.AddDbContext<WishlistDbContext>(options => \n options.UseNpgsql(builder.Configuration.GetConnectionString(\"DefaultConnection\")).UseSnakeCaseNamingConvention());[[endcode]]" },
  { "id": 6, "theme": "htmlcss", "title": "Sidebar scrolls with content", "info": "The sidebar scrolls with content. Alas, I'm not good with CSS, it's not interesting to me and ChatGPT couldn't help me." },
  { "id": 7, "theme": "react", "title": "It's ok to use LocalStorage for the JWT bearer token", "info": "A lot of developers seem to think that using localstorage for bearer tokens is an unsafe practice. In the follow article the autor claims that while using localstorage for bearer tokens is not optimal, it's not a security hole. https://pragmaticwebsecurity.com/articles/oauthoidc/localstorage-xss.html His point is that using your time to make sure your app is free of XSS vulnerabilities is better than spending your time coming up with a (slightly) better alternative to localstorage. React cheat sheet for avoiding XSS vulnerabilities: https://pragmaticwebsecurity.com/img/cheatsheets/reactxss.png" },
  { "id": 8, "theme": "dotnet", "title": "Optimistic concurrency in Entity Framework with Postgres", "info": "In our class where we want optimistic concurrency we add a uint RowVersion field with [TimeStamp] attribute. [[code]][Timestamp]\npublic uint RowVersion { get; set; }[[endcode]] In DbContext OnModelCreating we set it as RowVersion: [[code]]builder.Entity<AuctionBid>().Property(a => a.RowVersion).IsRowVersion();[[endcode]] In the migration add: [[code]]migrationBuilder.AddColumn<uint>(\n    name: \"xmin\",\n    table: \"auctions\",\n    type: \"xid\",\n    rowVersion: true,\n    nullable: false,\n    defaultValue: 0u);[[endcode]] Before save changes, RowVersion needs to be set in the following way instead of a normal assignment: [[code]]_context.Entry(auction).Property(a => a.RowVersion).OriginalValue = auctionBid.RowVersion;\n_context.Auctions.Update(auction);\n await _context.SaveChangesAsync();[[endcode]]Help found on https://github.com/npgsql/efcore.pg/issues/3270 \n Now, if we try to save a record that was updated by another user (RowVersion will be stale), we get a concurrency exception." },
  { "id": 9, "theme": "react", "title": "TanStack Router", "info": "Don't forget to use <Link> instead of <a> tags with TanStack Router. <a> tags will do full page reloads, <Link> will not." }
]

